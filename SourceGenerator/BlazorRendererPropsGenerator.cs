using System.Collections.Immutable;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace SourceGenerator;

[Generator]
public class BlazorRendererPropsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var razorFiles = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".razor", StringComparison.OrdinalIgnoreCase));

        var razorWithCodeBlocks = razorFiles
            .Select((file, ct) =>
            {
                var content = file.GetText(ct)?.ToString();
                var className = Path.GetFileNameWithoutExtension(file.Path);
                var fullClass = ExtractAndWrapCodeBlocks(content, className);
                var tree = CSharpSyntaxTree.ParseText(fullClass);
                var root = tree.GetRoot();

                var classNode = root.DescendantNodes().OfType<ClassDeclarationSyntax>().First();


                return new
                {
                    Path = file.Path,
                    ClassNode = classNode
                };
            });

        context.RegisterSourceOutput(razorWithCodeBlocks, (spc, result) =>
        {
            var className = result.ClassNode.Identifier.ToString();
            var methods = result.ClassNode.Members.OfType<MethodDeclarationSyntax>().Select(m => m.Identifier.Text);
            var properties = result.ClassNode.Members.OfType<PropertyDeclarationSyntax>().ToList();
            if (properties.Any() == false) return;
            var fields = result.ClassNode.Members.OfType<FieldDeclarationSyntax>().Select(f => f.Declaration.Variables.First().Identifier.Text);

            var codeBuilder = new StringBuilder();

            codeBuilder.AppendLine("""
                                   // <auto-generated />
                                   namespace Empty.Components
                                   {
                                   """);

            codeBuilder.AppendLine($$"""
                                         public partial class {{className}}
                                         {
                                             public record Props({{string.Join(", ", properties.Select(x => $"{x.Type.ToString()} {x.Identifier.Text}"))}})
                                             {
                                                 public static implicit operator Dictionary<string, object>(Props props) => new()
                                                 {
                                                     {{string.Join(",\n                ", properties.Select(x => $"[nameof(props.{x.Identifier.Text})] = props.{x.Identifier.Text}"))}}
                                                 };
                                             }
                                         }
                                     """);
            codeBuilder.AppendLine("""
                                   }
                                   """);
            spc.AddSource(
                hintName: Path.GetFileNameWithoutExtension(className) + "Props.g.cs",
                sourceText: SourceText.From(codeBuilder.ToString(), Encoding.UTF8)
            );
        });
    }

    private void Execute(SourceProductionContext context, (Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes) tuple)
    {
        var (compilation, classes) = tuple;

        var codeBuilder = new StringBuilder();
        var prefixCode = """
                         // <auto-generated />
                         namespace Empty.Components
                         {
                         """;

        codeBuilder.AppendLine(prefixCode);


        codeBuilder.AppendLine("""
                                   public partial class Index
                                   {
                                       public record Props(string Title, string Description)
                                       {
                                           public static implicit operator Dictionary<string, object>(Props props) => new()
                                           {
                                               [nameof(props.Title)] = props.Title, 
                                               [nameof(props.Description)] = props.Description
                                           };
                                       }
                                   }
                                   public partial class DisplayDate
                                   {
                                       public record Props(DateTime Today)
                                       {
                                           public static implicit operator Dictionary<string, object>(Props props) => new()
                                           {
                                               [nameof(props.Today)] = props.Today
                                           };
                                       }
                                   }
                               """);

        var suffixCode = """
                         }
                         """;
        codeBuilder.AppendLine(suffixCode);

        context.AddSource("Props.g.cs", codeBuilder.ToString());
    }


    private static string ExtractAndWrapCodeBlocks(string razorContent, string className)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"class {className}");
        sb.AppendLine("{");

        var index = 0;

        while (index < razorContent.Length)
        {
            var codeStart = razorContent.IndexOf("@code", index, StringComparison.OrdinalIgnoreCase);
            if (codeStart == -1)
                break;

            var braceStart = razorContent.IndexOf('{', codeStart);
            if (braceStart == -1)
                break;

            var braceCount = 0;
            var end = braceStart;

            for (; end < razorContent.Length; end++)
            {
                switch (razorContent[end])
                {
                    case '{':
                        braceCount++;
                        break;
                    case '}':
                        braceCount--;
                        break;
                }

                if (braceCount == 0)
                {
                    var inner = razorContent.Substring(braceStart + 1, end - braceStart - 1).Trim();
                    sb.AppendLine(inner);
                    index = end + 1;
                    break;
                }
            }

            if (braceCount != 0)
                break; // unbalanced, stop parsing
        }

        sb.AppendLine("}");
        return sb.ToString();
    }


    public static void AnalyzeCode(string codeBlockContent)
    {
        // Vi pakker ind i en dummy class for at kunne parse det
        var wrapped = $"class Dummy {{ {codeBlockContent} }}";

        var tree = CSharpSyntaxTree.ParseText(wrapped);
        var root = tree.GetRoot();

        var classNode = root.DescendantNodes().OfType<ClassDeclarationSyntax>().First();

        var methods = classNode.Members.OfType<MethodDeclarationSyntax>();
        var props = classNode.Members.OfType<PropertyDeclarationSyntax>();
        var fields = classNode.Members.OfType<FieldDeclarationSyntax>();

        Console.WriteLine("Methods:");
        foreach (var method in methods)
            Console.WriteLine($"- {method.Identifier}");

        Console.WriteLine("Properties:");
        foreach (var prop in props)
            Console.WriteLine($"- {prop.Identifier}");

        Console.WriteLine("Fields:");
        foreach (var field in fields)
        foreach (var variable in field.Declaration.Variables)
            Console.WriteLine($"- {variable.Identifier}");
    }
}